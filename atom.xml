<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mzqk.github.io</id>
    <title>MZZZ</title>
    <updated>2020-12-18T01:14:14.090Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mzqk.github.io"/>
    <link rel="self" href="https://mzqk.github.io/atom.xml"/>
    <subtitle>这世界总有些人做着美梦逆来顺受</subtitle>
    <logo>https://mzqk.github.io/images/avatar.png</logo>
    <icon>https://mzqk.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, MZZZ</rights>
    <entry>
        <title type="html"><![CDATA[Oracle日常运维]]></title>
        <id>https://mzqk.github.io/post/oracle-ri-chang-yun-wei/</id>
        <link href="https://mzqk.github.io/post/oracle-ri-chang-yun-wei/">
        </link>
        <updated>2020-12-17T01:37:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="oracle-常用运维命令整理">Oracle 常用运维命令整理</h2>
<h3 id="一-oracle建库与删库命令">一、oracle建库与删库命令</h3>
<p>（1）oracle11g建库(一般习惯配置gdbname与sid名一样，sys密码与system密码一样，以方便记忆)</p>
<pre><code>[oracledb@ ~]$ dbca -silent -createDatabase -templateName /u01/oracle/product/11.2.0/dbhome_1/assistants/dbca/templates/General_Purpose.dbc -gdbname GDBNAME -sid SIDNAME -characterSet AL32UTF8 -NATIONALCHARACTERSET UTF8 -sysPassword SYSPASSWORD -systemPassword SYSTEMPASSWORD -TOTALMEMORY 2048
</code></pre>
<p>删库方法一：</p>
<pre><code>[oracledb@ ~]$ dbca -silent -deleteDatabase -sourceDB  SIDNAME -sysDBAUserName sys -sysDBAPassword SYSPASSWORD
</code></pre>
<p>删除库方法二：</p>
<pre><code>#步骤1：配置回应文件：
[oracledb@ ~]$ cat /u01/oracle/response/dbca.rsp
OPERATION_TYPE = &quot;deleteDatabase&quot;
SOURCEDB = &quot;SIDNAME&quot;
SYSDBAUSERNAME = &quot;sys&quot;SYSDBA
PASSWORD = &quot;SYSPASSWORD&quot;

#步骤2：执行回应文件删库：
[oracledb@ ~]$ dbca -silent -responseFile /u01/oracle/response/dbca.rsp
</code></pre>
<p>（2）oracle12c  建库</p>
<pre><code>[oracledb@ ~]$ dbca -silent -createDatabase -templateName /u01/oracle/product/orahome/assistants/dbca/templates/General_Purpose.dbc  -gdbname GDBNAME -sid SIDNAME -characterSet AL32UTF8 -NATIONALCHARACTERSET UTF8 -sysPassword SYSPASSWORD -systemPassword SYSTEMPASSWORD -TOTALMEMORY 2048
#删库命令同上，注意运行删库命令之后，需要手动删除遗留的目录
</code></pre>
<p>（3）删除一般会自动删除以下路径或文件中的库信息</p>
<pre><code>A：/u01/oracle/admin/SIDNAME
B：cat /etc/oratab
C：/u01/oracle/oradata/SIDNAME
</code></pre>
<p>以下路径需要手动清理</p>
<pre><code>D：/u01/oracle/cfgtoollogs/dbca/SIDNAME
E：/u01/oracle/diag/rdbms/SIDNAME
F：/u01/oracle/product/11.2.0/dbhome_1/dbs/hc_SIDNAME.dat
</code></pre>
<h3 id="二-创建库对应的账号密码">二、创建库对应的账号密码</h3>
<p>1、切换SID</p>
<pre><code>[oracledb@ ~]$ export ORACLE_SID=SIDNAME
</code></pre>
<p>2、切换字符集</p>
<pre><code>#查看oracle数据库的字符集
SQL&gt; select userenv('language') from dual;

#查看oracle数据库的编码
SQL&gt; select * from nls_database_parameters where parameter ='NLS_CHARACTERSET';
[oracledb@ ~]$ set NLS_LANG=AMERICAN_AMERICA.AL32UTF8     #windows_os
[oracledb@ ~]$ export NLS_LANG=AMERICAN_AMERICA.AL32UTF8  #linux_os
</code></pre>
<p>3、创建库对应的用户信息</p>
<pre><code>SQL&gt; create temporary tablespace SIDNAME_temp tempfile '/u01/oracle/oradata/SIDNAME/SIDNAME_temp.dbf 'size 64m autoextend on next 64m maxsize unlimited extent management local;

SQL&gt; create tablespace SIDNAME_data logging datafile '/u01/oracle/oradata/SIDNAME/SIDNAME_data.dbf' size 64m autoextend on next 64m maxsize 2048m extent management local;

SQL&gt; create user USERNAME identified by USERPASSWORD default tablespace SIDNAME_data temporary tablespace SIDNAME_temp;

SQL&gt; grant connect,resource to USERNAME;
SQL&gt; grant create view to USERNAME;
SQL&gt; grant unlimited tablespace to USERNAME;

SQL&gt; grant create public synonym to USERNAME;
SQL&gt; grant drop public synonym to USERNAME;

SQL&gt; create or replace directory dir_dump  as '/u01/oracle/backup';
SQL&gt; grant read,write on directory dir_dump to USERNAME;

SQL&gt; ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;
</code></pre>
<p>—根据实例环境修改processes与sessions参数值(需要重启oracle数据库)</p>
<pre><code>SQL&gt; alter system set processes=1000 scope=spfile;  SQL&gt; alter system set sessions=1105 scope=spfile; 
</code></pre>
<p>知识点：</p>
<ul>
<li>oracle11g：sessions值的定义应该大于或者定于1.1processes+5，如果小于1.1processes+5，则oracle在启动时自动将该参数设置为1.1processes+5。这主要是考虑到后台进程发起的session和大约10%的递归session。</li>
<li>oracle12c：1.1processes+22</li>
</ul>
<pre><code>##查询当前oracle的并发连接数：
SQL&gt; select count(*) from v$session where status='ACTIVE';
#查看不同用户的连接数：
SQL&gt; select username,count(username) from v$session where username is not null group by username;
#查看所有用户：
select * from all_users;
#当前的连接数
select count(*) from v$process;
#数据库允许的最大连接数
select value from v$parameter where name = 'processes';
</code></pre>
<h3 id="三-数据库的还原与备份命令">三、数据库的还原与备份命令</h3>
<p>查看expdp导出备份存储路径：</p>
<pre><code>sql&gt; select * from dba_directories;
</code></pre>
<p>1、针对整个库备份与还原操作</p>
<p>（1）、数据库的备份(注意有时SIDNAME与SCHEMASNAME不一致，要注意使用时区分，一般配置一样的名称，方便记忆的同时，也方便运维。parallel参数根据服务器内存等配置情况添加合理的数值。)</p>
<pre><code>#备份：
[oracledb@ ~]$  expdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME dumpfile=SIDNAME`date +%Y%m%d`.dmp directory=dir_dump parallel=2
12
</code></pre>
<p>（2）、还原</p>
<p>情况1、原始库与目标库实例名不同（注意有些环境的数据表空间名不是SIDNAME_data，使用时注意核实）</p>
<pre><code>#格式：
[oracledb@ ~]$ impdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DUMPFILE=XXXX.dmp  DIRECTORY=dir_dump remap_schema=源SCHEMASNAME:目标SCHEMASNAME remap_tablespace=源_data:目标_data
</code></pre>
<p>情况2：源库与目标库实例名相同</p>
<pre><code>#格式：
[oracledb@ ~]$ impdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DUMPFILE=XXXX.dmp  DIRECTORY=dir_dump EXCLUDE=STATISTICS
</code></pre>
<p>知识扩展：使用EXCLUDE=STATISTICS还原时排除统计，可以使用如下命令完成统计</p>
<pre><code>#命令如下：
SQL&gt; exec dbms_stats.gather_schema_stats(ownname=&gt;'SIDNAME',estimate_percent=&gt;10,degree=&gt;8,cascade=&gt;true,granularity=&gt;'ALL');
</code></pre>
<p>2、针对单表备份与还原操作</p>
<p>（1）、备份单表</p>
<pre><code>格式：
[oracledb@ ~]$ expdp USERNAME/USERPASSWORD@SIDNAME dumpfile=tablenameXXXX.dmp DIRECTORY=dir_dump tables=TABLENAME
</code></pre>
<p>（2）、还原单表</p>
<pre><code>#格式：
[oracledb@ ~]$ impdp USERNAME/USERPASSWORD@SIDNAME dumpfile=tablenameXXXX.dmp DIRECTORY=dir_dump TABLES=TABLENAME TABLE_EXISTS_ACTION=REPLACE
</code></pre>
<p>扩展：table_exists_action参数说明</p>
<pre><code>使用imp进行数据导入时，若表已经存在，要先drop掉表，再进行导入。
而使用impdp完成数据库导入时，若表已经存在，有四种的处理方式：
参数(1) skip：默认操作
参数(2) replace：先drop表，然后创建表，最后插入数据
参数(3) append：在原来数据的基础上增加数据
参数(4) truncate：先truncate，然后再插入数据
</code></pre>
<p>（3）备份多张表</p>
<pre><code>#格式：
[oracledb@ ~]$ expdp USERNAME/USERPASSWORD@SIDNAME dumpfile=tablenameXXXX.dmp DIRECTORY=dir_dump TABLES=源TABLENAME1,源TABLENAME2,.....
</code></pre>
<p>（4）还原多张表</p>
<pre><code>#格式：
[oracledb@ ~]$ impdp USERNAME/USERPASSWORD@SIDNAME dumpfile=tablenameXXXX.dmp DIRECTORY=dir_dump remap_table=源TABLENAME1:目标TABLENAME11 TABLE_EXISTS_ACTION=REPLACE
[oracledb@ ~]$ impdp USERNAME/USERPASSWORD@SIDNAME dumpfile=tablenameXXXX.dmp DIRECTORY=dir_dump remap_table=源TABLENAME2:目标TABLENAME22 TABLE_EXISTS_ACTION=REPLACE
</code></pre>
<p>3、扩展知识</p>
<p>1）扩展1：</p>
<p>情况1、高版本往低版本导出还原时，如12往11还原时，在12c执行导出时，添加低版本的版本号version=11.1.0.2.0</p>
<pre><code>#格式：
[oracledb@ ~]$ expdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME dumpfile=XXX.dmp DIRECTORY=dir_dump version=11.1.0.2.0
</code></pre>
<p>情况2、低版本往高版本还原时，高版本一般兼容低版本，目前个人运维工作中11往12还原没遇到什么问题。</p>
<p>2）扩展2：</p>
<p>（1）、按指定大小备份，如每份5G大小（parallel是多线程处理，线程数要小于生成文件个数，线程要小于 cpu 线程数）</p>
<pre><code>#备份格式
[oracledb@ ~]$ expdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DIRECTORY=dir_dump dumpfile=XXX_%U.dmp logfile=expdpXXX.log filesize=5G parallel=16
</code></pre>
<p>（2）、多个备份文件还原：</p>
<pre><code>#还原格式
[oracledb@ ~]$ impdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DIRECTORY=dir_dump dumpfile=XXX_%U.dmp logfile=impdpXXX.log parallel=16
</code></pre>
<p>3）扩展3导出过滤不导出某张表：</p>
<pre><code>#格式
[oracledb@ ~]$ expdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DIRECTORY=dir_dump dumpfile=XXX.dmp  exclude=TABLE:\&quot;IN \'TABLENAME\'\&quot; 
</code></pre>
<p>4）扩展4不同库还原时不改变数据结构使用truncate参数：</p>
<pre><code>#格式
[oracledb@ ~]$ impdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DIRECTORY=dir_dump dumpfile=XXX.dmp remap_schema=源SCHEMASNAME:目标SCHEMASNAME remap_tablespace=源_data:目标_data TABLE_EXISTS_ACTION=truncate
</code></pre>
<p>5）扩展5导出备份时保留表，清除表数据(query参数)：</p>
<pre><code>#格式
[oracledb@ ~]$ expdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DIRECTORY=dir_dump dumpfile=XXX.dmp logfile=expdpXXX.log  query=TABLENAME1:'&quot; where 1=2&quot;',TABLENAME2:'&quot; where 1=2&quot;',........
</code></pre>
<p>6）扩展6导出备份时保留表，清除表数据，同时过滤某两张表</p>
<pre><code>#格式
[oracledb@ ~]$ expdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DIRECTORY=dir_dump dumpfile=XXX.dmp logfile=expdpXXX.log  query=TABLENAME1:'&quot; where 1=2&quot;',TABLENAME2:'&quot; where 1=2&quot;' exclude=TABLE:\&quot;IN \'TABLENAME1\'\'TABLENAME2\'\&quot;
</code></pre>
<p>7）扩展7仅统计数据库各表数据，但不导出，参数estimate_only=y</p>
<pre><code>#格式[oracledb@ ~]$ expdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME DIRECTORY=dir_dump estimate_only=y
</code></pre>
<p>8）扩展8导入单表到某临时表：</p>
<pre><code>#格式（涉及统计与索引时添加参数EXCLUDE=STATISTICS EXCLUDE=INDEX）
—sql实现从这张表复制到另一张临时表

SQL&gt; CREATE TABLE 目标TABLENAME  AS (SELECT * FROM 源TABLENAME);
—清空表中的数据

SQL&gt; delete  from 目标TABLENAME;
[oracledb@ ~]$ impdp USERNAME/USERPASSWORD@SIDNAME DIRECTORY=dir_dump DUMPFILE=tablenameXXX.dmp remap_table=源TABLENAME:目标TABLENAME TABLE_EXISTS_ACTION=REPLACE EXCLUDE=STATISTICS EXCLUDE=INDEX
 [oracledb@ ~]$ expdp USERNAME/USERPASSWORD@SIDNAME schemas=SCHEMASNAME ESTIMATE_ONLY=y NOLOGFILE=y FULL=y
</code></pre>
<p>9）扩展9个别sql脚本内容很长，使用PLSQL Developer工具执行时会一直卡住无响应时除使用PLSQL Developer工具的在命令窗口中执行外，也可以使用shell终端执行</p>
<pre><code>#格式
[oracle@localhost ~]$ export ORACLE_SID=SIDNAME
[oracle@localhost ~]$ sqlplus  / as sysdba
sql&gt; conn USERNAME/USERPASSWORD@SIDNAME
sql&gt; @/u01/oracle/backup/XXX.sql
</code></pre>
<p>10）扩展10如何正确终止expdp与impdp任务，操作步骤如下：</p>
<pre><code>步骤1、查看视图dba_datapump_jobs

select job_name,state from dba_datapump_jobs;
步骤2、正确停止expdp导出任务使用stop_job

expdp USERNAME/USERPASSWORD@SIDNAME attach=SYS_EXPORT_SCHEMA_02
步骤3、停止任务

Export&gt; stop_job=immediate 
Are you sure you wish to stop this job ([yes]/no): yes  
步骤4、查看系统中的备份job状态

select owner_name,job_name ,state from dba_datapump_jobs;
</code></pre>
<p>扩展：下列命令在交互模式下有效：</p>
<pre><code>HELP： 总结交互命令。
KILL_JOB： 分离和删除作业。
PARALLEL： 更改当前作业的活动 worker 的数目。
PARALLEL=.2
START_JOB： 启动/恢复当前作业。
START_JOB=SKIP_CURRENT 在开始作业之前将跳过作业停止时执行的任意操作。
STATUS ：在默认值（0）将显示可用时的新状态的情况下，要监视的频率（以秒计）作业状态。
STATUS[=interval]
STOP_JOB： 顺序关闭执行的作业并退出客户机。
STOP_JOB=IMMEDIATE 将立即关闭数据泵作业。
</code></pre>
<p>11）扩展11</p>
<pre><code>#查看DB中的NLS_CHARACTERSET的值
SQL&gt; select * from v$nls_parameters  where parameter='NLS_CHARACTERSET'; 
SQL&gt; select * from nls_database_parameters t where t.parameter='NLS_CHARACTERSET';
</code></pre>
<p>12）扩展12关于exp、imp、expdp、impdp</p>
<pre><code>(1)、exp和imp是客户端工具程序，它们既可以在客户端使用，也可以在服务端使用。
(2)、expdp和impdp是服务端的工具程序，他们只能在oracle服务端使用，不能在客户端使用。
(3)、imp只适用于exp导出的文件，不适用于expdp导出文件；impdp只适用于expdp导出的文件，而不适用于exp导出文件。
(4)、对于10g以上的服务器，使用exp通常不能导出0行数据的空表，而此时必须使用expdp导出。
</code></pre>
<p>13）扩展13oracle用户密码有@符号时，expdp与sqlplus连接方式及使用rar压缩备份的文件</p>
<pre><code>@echo off
rem ---- dmp backup directory, same as dump dir
set backup_dir=e:\app\oracle\backup
rem ---- today, day for dmp file remaining
set day=%date:~0,4%%date:~5,2%%date:~8,2%
set remain_day=7

rem --- delete files before 7 days
forfiles /p &quot;%backup_dir%&quot; /d -%remain_day%  /c &quot;cmd /c del /f @path&quot;

rem --- export oracle data to dmp file
expdp 用户名/\&quot;xxx@yyy\&quot;@orcl directory=dir_dump dumpfile=用户名_%day%.dmp logfile=用户名_%day%.log schemas=用户名 parallel=4 compression=ALL
rem --- sqlplus conn
sqlplus 用户名/&quot;&quot;&quot;xxx@yyy&quot;&quot;&quot;@orcl

rem ---- if compress the dumpfile and delete source dumpfile, unmark rem

set rar=&quot;C:\Program Files (x86)\WinRAR\WinRAR.exe&quot;

%rar% a -df %backup_dir%\用户名_%day%.rar %backup_dir%\用户名_%day%.dmp %backup_dir%\用户名_%day%.log
</code></pre>
<h3 id="四-清理还原时出错清用户表空间">四、清理（还原时出错，清用户表空间）</h3>
<p>1、删除数据表空间：</p>
<pre><code>#执行语句：
[oracledb@ ~]$ sqlplus / as sysdbaSQL&gt; drop tablespace mepro_data including contents and datafiles cascade constraint;
</code></pre>
<p>2、删除临时表空间：</p>
<pre><code>#执行语句：
SQL&gt; drop tablespace mepro_temp including contents and datafiles cascade constraints;
</code></pre>
<p>3、删除用户：</p>
<pre><code>#执行语句：
SQL&gt; drop user srmhdld cascade;
</code></pre>
<p>4、报用户正在连接，无法删除的解决方法</p>
<pre><code>---方法1：重启并迅速执行drop user语句（个人推荐）
SQL&gt; shutdown immediate;
SQL&gt; startup

---方法2：删除正在连接的session（连接的session连接着很多时，清理耗时，没有方法1快速）
#查询用户会话
SQL&gt; select username,serial#,sid,program,machine,status from v$session where username='USERNAME' AND STATUS='ACTIVE';;
SQL&gt; select saddr,sid,serial#,paddr,username,status from v$session where username is not null;

---删除相关用户会话
SQL&gt; alter system kill session 'serial#, sid';
</code></pre>
<p><em>文章转自：</em><a href="https://mp.weixin.qq.com/s/j2dYPUtX5gRwSXq7SRYa_g">运维派</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 离线安装应用]]></title>
        <id>https://mzqk.github.io/post/linux-chi-xian-an-zhuang-ying-yong/</id>
        <link href="https://mzqk.github.io/post/linux-chi-xian-an-zhuang-ying-yong/">
        </link>
        <updated>2020-11-25T07:29:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="linux安装应用">Linux安装应用</h1>
<h2 id="包安装">包安装</h2>
<h3 id="国内常用源库">国内常用源库</h3>
<blockquote>
<p>以下为国内常用源，可根据区域不同自行选择速度最快的源。若是在线安装，可参照网站指南配置，这里就不赘述了。</p>
</blockquote>
<ul>
<li><a href="https://developer.aliyun.com/mirror/">阿里云官方镜像站</a></li>
<li><a href="https://mirrors.cloud.tencent.com/">腾讯云软件源</a></li>
<li><a href="https://mirrors.huaweicloud.com/">华为开源镜像站</a></li>
<li><a href="%5Bhttp://mirrors.163.com/">网易开源镜像站</a></li>
<li><a href="http://mirror.hust.edu.cn/">华中科技大学开源镜像站</a></li>
<li><a href="http://mirrors.zju.edu.cn/">浙江大学开源镜像站</a></li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a></li>
<li><a href="http://mirrors.cqu.edu.cn/">重庆大学开源软件镜像站</a></li>
</ul>
<h3 id="常用软件管理机制">常用软件管理机制</h3>
<ul>
<li><strong>DPKG</strong> Debian类发行版包管理，格式为xxx.deb</li>
<li><strong>RPM</strong> Cento类发行版包管理，格式为xxx.rpm</li>
<li><strong>SRPM</strong> Centos类发行版未编译包，格式为xxx.src.rpm</li>
<li><strong>APT</strong> Debian类发行版在线包管理</li>
<li><strong>YUM</strong> Centos类发行版在线包管理</li>
<li><strong>Snap</strong> Ubuntu应用包管理</li>
<li><strong>Opkg</strong> Opensource嵌入式包管理，常见为Openwrt路由系统软件包工具，格式为xxx.ipk</li>
<li><strong>DNF</strong> Fedora类发行版在线包管理</li>
<li><strong>Pacman</strong> Archlinux类发行版在线包管理</li>
</ul>
<h3 id="常见软件源cpu架构">常见软件源CPU架构</h3>
<blockquote>
<p>各类发行版的CPU架构不同，可基本按照大类根据服务器的CPU去软件源路径目录进入。</p>
<p>注：noarch代表没有硬件等级上的限制，不缺分服务器系统都可安装，但存在部分依赖包关联不到的问题。</p>
</blockquote>
<ul>
<li><strong>ARM系处理器</strong>：arm64、aarch64、armv6h、armv7h、armhf 、armel</li>
<li><strong>X86系处理器</strong>：i386、i586、i686、amd64 、x86_64</li>
<li><strong>MIPS处理器</strong>：mips64el、mips、mips64e、mipsel</li>
<li><strong>PowerPC处理器</strong>：ppc64le</li>
</ul>
<h3 id="实践">实践</h3>
<blockquote>
<p>以下以服务器在无外网的情况下安装nginx为例</p>
</blockquote>
<ol>
<li>查看服务器版本</li>
</ol>
<pre><code class="language-bash"># cat /proc/version
Linux version 3.10.0-514.26.2.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-11) (GCC) ) #1 SMP Tue Jul 4 15:04:05 UTC 2017
</code></pre>
<p>这里查到CPU架构为x86_64、操作系统为ed Hat 4.8.5-11（这里查到的版本为Red Hat 4.8.5-11对应官方开发进度为Centos7.8，也可使用<code>cat /etc/redhat-release</code> 查看红帽的社区版本）、使用的包管理工具为RPM</p>
<ol start="2">
<li>下载相应Nginx离线包</li>
</ol>
<p>进入nginx<a href="http://nginx.org/en/download.html">官网</a>根据安装文档http://nginx.org/en/linux_packages.html找到源库http://nginx.org/packages，对应<strong>Centos7</strong>操作系统版本<strong>x86_64</strong>位找到安装包http://nginx.org/packages/centos/7/x86_64/RPMS/nginx-1.16.1-1.el7.ngx.x86_64.rpm</p>
<ol start="3">
<li>使用相应包管理工具安装Nginx</li>
</ol>
<pre><code class="language-bash"># rpm -ivh nginx-1.16.1-1.el7.ngx.x86_64.rpm 
warning: nginx-1.16.1-1.el7.ngx.x86_64.rpm: Header V4 RSA/SHA1 Signature, key ID 7bd9bf62: NOKEY
error: Failed dependencies:
	libc.so.6(GLIBC_2.14)(64bit) is needed by nginx-1:1.16.1-1.el7.ngx.x86_64
	libc.so.6(GLIBC_2.17)(64bit) is needed by nginx-1:1.16.1-1.el7.ngx.x86_64
	libcrypto.so.10(OPENSSL_1.0.2)(64bit) is needed by nginx-1:1.16.1-1.el7.ngx.x86_64
	libcrypto.so.10(libcrypto.so.10)(64bit) is needed by nginx-1:1.16.1-1.el7.ngx.x86_64
	libpcre.so.1()(64bit) is needed by nginx-1:1.16.1-1.el7.ngx.x86_64
	libssl.so.10(libssl.so.10)(64bit) is needed by nginx-1:1.16.1-1.el7.ngx.x86_64
	openssl &gt;= 1.0.2 is needed by nginx-1:1.16.1-1.el7.ngx.x86_64
	systemd is needed by nginx-1:1.16.1-1.el7.ngx.x86_64

</code></pre>
<p>这里安装报错需要处理依赖程序，可根据提示中的信息去搜索指定版本依赖文件，如无报错则安装成功。依赖包可能存在与Centos源中，也可能存在<a href="http://nginx.org/packages">Nginx软件源</a>中。</p>
<ol start="4">
<li>进入相应镜像库下载所需要的依赖包</li>
</ol>
<p>登录<a href="https://developer.aliyun.com/mirror/">阿里云镜像站</a>进入centos页面点击<a href="https://mirrors.aliyun.com/centos">下载地址</a>，根据上面查到的服务器版本进入相应目录搜索包https://mirrors.aliyun.com/centos/7/os/x86_64/Packages/或https://mirrors.aliyun.com/centos/7/extras/x86_64/Packages/</p>
<p>也可以直接搜索相应包下载https://developer.aliyun.com/packageSearch</p>
<ol start="5">
<li>安装所有依赖包</li>
</ol>
<pre><code class="language-bash"># rpm -ivh *
</code></pre>
<p>若出现安装顺序问题，可按提示顺序一个个单独安装</p>
<h2 id="源码安装">源码安装</h2>
<h2 id="自建源在线安装">自建源在线安装</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kubernetes基础概念]]></title>
        <id>https://mzqk.github.io/post/kubernetes-ji-chu-gai-nian/</id>
        <link href="https://mzqk.github.io/post/kubernetes-ji-chu-gai-nian/">
        </link>
        <updated>2020-10-22T02:01:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="master">Master</h2>
<h3 id="apiserver">Apiserver</h3>
<h3 id="controller-manager">Controller Manager</h3>
<h4 id="rc">RC</h4>
<p>副本控制器，通过一条标签选择 pod</p>
<h4 id="rs">RS</h4>
<p>副本控制器进化版，可以通过一组标签选择 pod</p>
<h4 id="deployment">Deployment</h4>
<p>管理副本控制器，可以声明式升级</p>
<p>deployment由replicaSet组成</p>
<h4 id="daemonset">DaemonSet</h4>
<p>每一个Node上都调度一个pod</p>
<h4 id="statefulset">Statefulset</h4>
<p>有状态部属pod</p>
<h4 id="job">Job</h4>
<p>启动一个批处理任务</p>
<h4 id="cronjob">CronJob</h4>
<p>定时启动一个批处理任务</p>
<h3 id="etcd">Etcd</h3>
<h3 id="schedule">Schedule</h3>
<h2 id="node">Node</h2>
<h3 id="kube-proxy">kube Proxy</h3>
<h3 id="kubelet">Kubelet</h3>
<h3 id="docker">Docker</h3>
<h2 id="资源">资源</h2>
<h3 id="pod">Pod</h3>
<p>一个pod中包含一个或多个容器<br>
pod中的容器不能跨节点</p>
<p>pod和pod之间是在同一个共享网络（多个容器组构成）</p>
<p>pod之间容器与容器共享网络和存储</p>
<p>pod的生命周启pending、running、successed、failed、unknow</p>
<p>pod中的pause可以判断业务容器的状态</p>
<p>pod可以使用hostport配置蒋端口暴露到所在的节点服务器上</p>
<h3 id="service">Service</h3>
<p>server能创建一个虚拟集群IP作为多个pod个通讯，service不能直接被ping</p>
<p>service访问pod实际是访问endpoints，endpoints由podid+暴露端口组成</p>
<p>service使用clusterip时，访问pod默认轮询分配到pod上</p>
<p>service使用clusterip且配置会话保持时，访问pod是基于clientip来分配到同一个pod上</p>
<p>service使用headless时，访问service分配到的pod由程序自己决定</p>
<p>service使用nodeport时，所有节点都能通过端口访问，若有负载均衡配置时可使用loadbalancer参数</p>
<h3 id="ingress">Ingress</h3>
<h3 id="label">label</h3>
<h3 id="annotation">Annotation</h3>
<h4 id="健康检查">健康检查</h4>
<p>livenessProbe</p>
<p>readlinessProbe</p>
<h2 id="网络原理">网络原理</h2>
<h3 id="kubernetes网络模型">Kubernetes网络模型</h3>
<p>Kubernetes网络模型设计的一个基础原则是：每个Pod都拥有一个独立的IP地址，并假定所有Pod都在一个可以直接连通的、扁平的网络空间中。</p>
<h3 id="docker网络模型">Docker网络模型</h3>
<h3 id="kubernetes网络实现">Kubernetes网络实现</h3>
<p>pod内容器之间通讯依赖同一个网络共享空间</p>
<p>pod和pod之间单节点通讯依赖docker网络<br>
pod和pod之间多节点通讯依赖kube_proxy(pod和node之间的关联,前提：docker网桥地址不同、pod容器组地址不同）</p>
<h3 id="docker网络实现">Docker网络实现</h3>
<p>doker默认使用网桥网络模式</p>
<p>docker服务端启动会建立一个虚拟网桥docker0得到指定的子网，每启动一个容器便会建立一个虚拟以太网veth，veth一端连接docker0另一端连接容器中的使用linux网络命名空间创建的eth0，eth0的IP由docker0地址段中分配</p>
<p>容器端口想要映射到服务上需使用NAT模式进行网路地址转换</p>
<p>为了实现多主机间docker通讯简单便有了CNM网络模型</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Oracle数据库迁移]]></title>
        <id>https://mzqk.github.io/post/oracle-shu-ju-ku-qian-yi/</id>
        <link href="https://mzqk.github.io/post/oracle-shu-ju-ku-qian-yi/">
        </link>
        <updated>2020-09-26T06:30:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数据库迁移">数据库迁移</h1>
<h2 id="备份数据">备份数据</h2>
<pre><code class="language-bash"># 远程导出数据
expdp system/system@192.168.1.1/orcl directory=DATA_PUMP_DIR dumpfile=expdpfulldb.dmp logfile=expdp.log full=y
# 本地导出数据
exp sys/password file=e:\fulldb.dmp log=e:\fulldb_exp.log full=y
</code></pre>
<h2 id="创建表空间">创建表空间</h2>
<pre><code class="language-sql">-- 系统相关表空间自行去除，若有后增的两个以上表空间则再次手动建立
SELECT 'create tablespace ' || NAME || ' datafile ' || '''/home/oracle/app/oracle/oradata/ora92i/' || NAME || '.dbf''' || ' size ' || '1024M auto extends on;'  FROM v$TABLESPACE
</code></pre>
<h2 id="导入数据">导入数据</h2>
<pre><code class="language-bash">impdp system/system directory=DATA_PUMP_DIR dumpfile=expdpfulldb.dmp logfile=impdp.log schemas=(业务表用户，多个使用逗号分隔)
</code></pre>
<h2 id="设置定时备份任务">设置定时备份任务</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ansible使用入门]]></title>
        <id>https://mzqk.github.io/post/ansible-shi-yong-ru-men/</id>
        <link href="https://mzqk.github.io/post/ansible-shi-yong-ru-men/">
        </link>
        <updated>2020-09-17T07:35:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ansible基础使用">Ansible基础使用</h1>
<h2 id="准备工作">准备工作</h2>
<h3 id="ssh免密登录">ssh免密登录</h3>
<ol>
<li>生成本地公私钥</li>
<li>上传私钥至被控服务器</li>
<li>验证登录</li>
</ol>
<pre><code class="language-bash">ssh-keygen
ssh-copy-id -i ~/.ssh/id_rsa.pub remote_username@server_ip_address
ssh remote_username@server_ip_address
</code></pre>
<h3 id="添加被控服务器信息">添加被控服务器信息</h3>
<pre><code class="language-bash">echo &quot;first.example.org&quot; &gt;&gt; /etc/ansible/hosts
</code></pre>
<h2 id="ad-hoc-commands">Ad-Hoc Commands</h2>
<p><strong>Ad-Hoc Commands 可以翻译为简短地指令。</strong></p>
<pre><code class="language-bash">$ ansible all -m ping
server1 | SUCCESS =&gt; {
    &quot;changed&quot;: false,
    &quot;ping&quot;: &quot;pong&quot;
}
</code></pre>
<pre><code class="language-bash">$ ansible all -m command -a &quot;echo Hello World&quot;
server1 | SUCCESS | rc=0 &gt;&gt;
Hello World
</code></pre>
<h3 id="常用模块">常用模块</h3>
<ul>
<li>ping</li>
<li>setup</li>
<li>command</li>
<li>shell</li>
<li>cron</li>
<li>user、group</li>
<li>cpoy</li>
<li>file</li>
<li>yum、apt</li>
<li>service</li>
<li>script</li>
</ul>
<h2 id="playbooks">Playbooks</h2>
<p><strong>Playbooks 是 Ansible 的脚本 。</strong></p>
<pre><code class="language-bash">$ vi hello_world.yml
---
- name: say 'hello world'
  hosts: all
  tasks:

    - name: echo 'hello world'
      command: echo 'hello world'
      register: result

    - name: print stdout
      debug:
        msg: &quot;&quot;
</code></pre>
<pre><code class="language-bash">$ ansible-playbook hello_world.yml

PLAY [say 'hello world'] *******************************************************

TASK [setup] *******************************************************************
ok: [server1]

TASK [echo 'hello world'] ******************************************************
changed: [server1]

TASK [print stdout] ************************************************************
ok: [server1] =&gt; {
    &quot;msg&quot;: &quot;hello world&quot;
}

PLAY RECAP *********************************************************************
server1                    : ok=3    changed=1    unreachable=0    failed=0
</code></pre>
<h2 id="roles">Roles</h2>
<p><strong>Roles 可以降低 Playbooks 的复杂性，更可以增加 Playbooks 的可用性。</strong></p>
<pre><code class="language-bash">$ tree .
.
└── example_role
    ├── README.md     # 说明文件
    ├── defaults
    │   └── main.yml  # 可被覆写的变数。
    ├── files         # 需复制到 Managed node 的档案。
    ├── handlers
    │   └── main.yml  # 主要的 handler。
    ├── meta
    │   └── main.yml
    ├── tasks
    │   └── main.yml  # 主要的 task。
    ├── templates     # 集中存放 Jinja2 模板的目录。
    ├── tests
    │   ├── inventory
    │   └── test.yml
    └── vars
        └── main.yml  # 不该被覆写的变数。

9 directories, 8 files
</code></pre>
<h2 id="常用配置">常用配置</h2>
<h3 id="inventory文件">Inventory文件</h3>
<p><strong>Ansible 可同时操作属于一个组的多台主机,组和主机之间的关系通过 inventory 文件配置. 默认的文件路径为 /etc/ansible/hosts</strong></p>
<h3 id="ansiblecfg">ansible.cfg</h3>
<p><strong>Ansible主要功能配置文件，默认的文件路径为/etc/ansible/ansible.cfg</strong></p>
<ul>
<li>inventory<br>
这个是默认库文件位置,脚本,或者存放可通信主机的目录:</li>
</ul>
<blockquote>
<p>inventory = /etc/ansible/hosts</p>
</blockquote>
<ul>
<li>library<br>
这个是Ansible默认搜寻模块的位置:</li>
</ul>
<blockquote>
<p>library = /usr/share/ansible</p>
</blockquote>
<ul>
<li>remote_tmp<br>
Ansible 通过远程传输模块到远程主机,然后远程执行,执行后在清理现场.在有些场景下,你也许想使用默认路径希望像更换补丁一样使用, 这时候你可以使用这个选项.:</li>
</ul>
<blockquote>
<p>remote_tmp = $HOME/.ansible/tmp<br>
<em>默认路径是在用户家目录下属的目录.Ansible 会在这个目录中使用一个随机的文件夹名称.</em></p>
</blockquote>
<ul>
<li>forks<br>
这个选项设置在与主机通信时的默认并行进程数.如果你有很多的主机, 高数值将会使得跨主机行为变快.默认值比较保守:</li>
</ul>
<blockquote>
<p>forks=5</p>
</blockquote>
<ul>
<li>poll_interval<br>
对于Ansible中的异步任务, 这个是设置定义,当具体的poll interval 没有定义时,多少时间回查一下这些任务的状态, 默认值是一个折中选择15秒钟.这个时间是个回查频率和任务完成叫回频率和当任务完成时的回转频率的这种:</li>
</ul>
<blockquote>
<p>poll_interval=15</p>
</blockquote>
<ul>
<li>sudo_user<br>
这个是sudo使用的默认用户,如果<code>–sudo-user</code> 没有特指或者’sudo_user’ 在Ansible playbooks中没有特指,在大多数的逻辑中 默认为: ‘root’</li>
</ul>
<blockquote>
<p>sudo_user=root</p>
</blockquote>
<ul>
<li>ask_sudo_pass<br>
类似 ask_pass,用来控制Ansible playbook 在执行sudo之前是否询问sudo密码.默认为no:</li>
</ul>
<blockquote>
<p>ask_sudo_pass=True<br>
<em>如果用户使用的系统平台开启了sudo 密码的话,应该开绿这一参数</em></p>
</blockquote>
<ul>
<li>ask_pass<br>
这个可以控制,Ansible 剧本playbook 是否会自动默认弹出弹出密码.默认为no::</li>
</ul>
<blockquote>
<p>ask_pass=True<br>
<em>如果使用SSH 密钥匙做身份认证.可能需要修改这一参数</em></p>
</blockquote>
<ul>
<li>remote_port<br>
这个设置是你系统默认的远程SSH端口,如果不指定,默认为22号端口:</li>
</ul>
<blockquote>
<p>remote_port = 22</p>
</blockquote>
<ul>
<li>roles_path<br>
roles 路径指的是’roles/’下的额外目录,用于playbook搜索Ansible roles.比如, 如果我们有个用于common roles源代码控制仓库和一个不同的 playbooks仓库,你也许会建立一个惯例去在 /opt/mysite/roles 里面查找roles.:</li>
</ul>
<blockquote>
<p>roles_path = /opt/mysite/roles<br>
<em>Roles将会在playbook目录中开始搜索.如果role没有找到,这个参数指定了其它可能的搜索路径.</em></p>
</blockquote>
<ul>
<li>timeout<br>
这个是默认SSH连接尝试超时时间:</li>
</ul>
<blockquote>
<p>timeout = 10</p>
</blockquote>
<ul>
<li>remote_user<br>
这是个ansible使用/usr/bin/ansible-playbook链接的默认用户名. 注意如果不指定,/usr/bin/ansible默认使用当前用户名称:</li>
</ul>
<blockquote>
<p>remote_user = root</p>
</blockquote>
<ul>
<li>log_path<br>
如果出现在ansible.cfg文件中.Ansible 将会在选定的位置登陆执行信息.请留意用户运行的Ansible对于logfile有权限:</li>
</ul>
<blockquote>
<p>log_path=/var/log/ansible.log<br>
<em>这个特性不是默认开启的.如果不设置,ansible将会吧模块加载纪录在系统日志系统中.不包含用密码.</em></p>
</blockquote>
<ul>
<li>module_name<br>
这个是/usr/bin/ansible的默认模块名（-m）. 默认是’command’模块. 之前提到过,command模块不支持shell变量,管道,配额. 所以也许你希望把这个参数改为’shell’:</li>
</ul>
<blockquote>
<p>module_name = command</p>
</blockquote>
<ul>
<li>executable<br>
这个选项可以在sudo环境下产生一个shell交互接口. 用户只在/bin/bash的或者sudo限制的一些场景中需要修改.大部分情况下不需要修改:</li>
</ul>
<blockquote>
<p>executable = /bin/bash</p>
</blockquote>
<ul>
<li>private_key_file<br>
如果你是用pem密钥文件而不是SSH 客户端或秘密啊认证的话,你可以设置这里的默认值,来避免每一次提醒设置密钥文件位置<code>–ansible-private-keyfile</code>:</li>
</ul>
<blockquote>
<p>private_key_file=/path/to/file.pem</p>
</blockquote>
<ul>
<li>display_skipped_hosts<br>
如果设置为<code>False</code>,ansible 将不会显示任何跳过任务的状态.默认选项是现实跳过任务的状态::</li>
</ul>
<blockquote>
<p>display_skipped_hosts=True</p>
</blockquote>
<ul>
<li>system_warnings<br>
允许禁用系统运行ansible相关的潜在问题警告（不包括操作主机）:</li>
</ul>
<blockquote>
<p>system_warnings = True<br>
*这个包括第三方库或者一些需要解决问题的警告.</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[钻石选购指南]]></title>
        <id>https://mzqk.github.io/post/zuan-shi-xuan-gou-zhi-nan/</id>
        <link href="https://mzqk.github.io/post/zuan-shi-xuan-gou-zhi-nan/">
        </link>
        <updated>2020-09-04T01:59:41.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/22911557">https://www.zhihu.com/question/22911557</a></p>
<p>钻石4C由<a href="https://www.gia.edu/">GIA</a>创立的标准，包括：颜色(Color)、净度（Clarity)、切工(Cut)和克拉重量(Carat)。</p>
<h2 id="重量">重量 ☆☆☆☆☆</h2>
<p>10分=1克拉</p>
<p>30分及以下无价值</p>
<p><strong>31分至1克拉有回收价值但不保值</strong></p>
<p>50分到70分相对平衡</p>
<p>1克拉以上有收藏价值且有相对较高的回收价值</p>
<h2 id="颜色">颜色 ☆☆☆☆☆</h2>
<p>在白钻的价值体系中，越接近无色或说白色的钻石，价值越高</p>
<p>颜色等级从D至Z，<strong>H为中间色</strong></p>
<p>H色之后的都有肉眼可见的偏黄</p>
<h2 id="净度">净度 ☆☆☆☆</h2>
<p>净度分级（在10倍放大镜下观察，钻石内含物或表面特征）：</p>
<p>FL（无瑕级）：没有任何内含物或表面瑕疵；</p>
<p>IF（内无瑕级）：内部没有任何内含物，而表面有微不足道的瑕疵，可借由磨光去除；</p>
<p><strong>VVS1 / VVS2（极轻微内含级）</strong>：钻石有极微细的瑕疵，即使专业鉴定师也很难看到；</p>
<p><strong>VS1 / VS2（轻微内含级）</strong>：钻石含有不易察觉的微小瑕疵；</p>
<p>SI1 / SI2（微内含级）：钻石有可见的瑕疵；</p>
<p>I1 / I2 / I3（内含级）：瑕疵非常明显，肉眼观察亦可看见，并且影响钻石的坚固度、透明度和闪亮度</p>
<p>瑕疵种类：</p>
<p>Chip（破损/裂痕）：表面上的浅损口，特指在钻石切磨完成后才发生的损伤；</p>
<p>Cavity（空洞）：钻石表面的晶体掉落或在切磨过程中所留下的坑洞；</p>
<p>Bruise（擦伤）：向内部放射状的棉絮构造伤痕，一般伴随有裂纹区域；</p>
<p>Abrasion（磨损）：刻面棱线上一系列极细微的小缺口</p>
<p>Scratch（划痕）：表面细小白雾状线痕，多为钻石互相摩擦所致</p>
<p><strong>Pinpoint（针点）</strong>：很小的晶体，10倍放大下看似小点，绝大多数针点为白色；</p>
<p><strong>Cloud（云状物）</strong>：由紧聚的针点组成，聚集一起时呈雾白或粉状；</p>
<p><strong>Feather（羽状物）</strong>：泛指钻石内的任何羽状纹路</p>
<p><strong>Included crystal（晶状体）</strong>：包裹在钻石内部微小的矿物晶体</p>
<p><strong>Needle（针状物）</strong>：钻石内部所含的细长晶体。多为白色，部分为暗色</p>
<p><strong>Pit（白点）</strong>：在10倍放大镜下看似白点，实为非常细小的气孔。</p>
<h2 id="切工">切工 ☆☆☆☆</h2>
<p>以圆形钻石为例</p>
<p>圆形钻石共有58个刻面（尖底也算一个刻面），包括：台面、风筝面、星刻面（又称三角面）、上腰面、下腰面、亭部主刻面、底小面（若底部为小尖则无此刻面）</p>
<p>圆形钻石公有3个部分：冠面、腰围和底部</p>
<p>切工的指标：</p>
<p><strong>Cut Grade 切工</strong>：是否按照圆钻的既定比例范围进行切合</p>
<p><strong>Polish 抛光</strong>：钻石刻面抛光纹是否明显，简单理解就是钻石表面的光滑度怎样</p>
<p><strong>Symmetry对称性</strong>：整个钻石的圆度；冠部与亭部刻尖点是否对齐；刻面尖点是否尖锐；同种刻面大小是否一致；台面和腰部是否平行等</p>
<p>指标的等级：</p>
<p>**EXCELLENT（EX）完美：**几乎反射了所有进入的光线，约有3%的钻石能够达到；</p>
<p><strong>VERY GOOD（VG）很好</strong>：反射出标准切工等级的光线，约有15%的钻石可以达到；</p>
<p>GOOD（G）好：反射了大部分进入钻使内部的光，约有35%的钻石可以达到；</p>
<p>FAIR（F）一般：也能反射光芒但表现一般，但较GOOD切工更差一些；</p>
<p>POOR（P）差：所有切工标准都没有达到，意味着切工非常差；</p>
<h2 id="其他">其他</h2>
<h3 id="证书">证书 ☆☆☆☆</h3>
<p>国际证书种类：</p>
<p><strong>GIA</strong>（美国宝石学院出具）</p>
<p><strong>HRD</strong>（比利时钻石高阶层会议联盟出具）</p>
<p><strong>IGI</strong>（<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%25E5%259B%25BD%25E9%2599%2585%25E5%25AE%259D%25E7%259F%25B3%25E5%25AD%25A6%25E9%2599%25A2/8430558%2522%2520%255Ct%2520%2522https%3A//baike.baidu.com/item/_blank">国际宝石学院</a>出具，总部位于安特卫普）</p>
<p>国内证书:</p>
<p>NGTC（国检证书，由中国国家珠宝玉石质量监督检验管理中心出具，同时还有一些下属分支实验室出具的机构证书，如南京国检、深圳国检等，采用相同的检测标准）</p>
<p>省检证书（由中国个省级珠宝检测中心出具，目的是便捷于各省的珠宝产品的检测，较常见的有：广东省检、江苏省建、浙江省检等等）</p>
<h3 id="荧光">**荧光 **☆☆☆</h3>
<p>荧光等级：</p>
<p><strong>None 无荧光</strong></p>
<p>Faint 微荧光</p>
<p>Mediue 中荧光</p>
<p>Strong 强硬光</p>
<p>Very Strong 极强荧光</p>
<h3 id="钻石腰码">钻石腰码 ☆☆☆☆</h3>
<p>腰码为证书上相应身份数字</p>
<h3 id="证书日期">证书日期 ☆☆</h3>
<p>证书产品经加工到线下店成品至少需要2个月</p>
<h3 id="戒托">戒托 ☆</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tomcat 启用 SSL]]></title>
        <id>https://mzqk.github.io/post/tomcat-qi-yong-ssl/</id>
        <link href="https://mzqk.github.io/post/tomcat-qi-yong-ssl/">
        </link>
        <updated>2020-08-04T05:54:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="tomcat-配置-ssl">Tomcat 配置 SSL</h1>
<h2 id="申请证书">申请证书</h2>
<ol>
<li>申请域名</li>
<li>绑定域名</li>
<li>证书申请</li>
<li>下载证书</li>
</ol>
<h2 id="配置-tomcat">配置 Tomcat</h2>
<h3 id="启用ssl">启用SSL</h3>
<blockquote>
<p>conf/server.xml</p>
</blockquote>
<pre><code>&lt;Connector  port=&quot;8443&quot;
protocol=&quot;HTTP/1.1&quot;
  port=&quot;8443&quot; SSLEnabled=&quot;true&quot;
  maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
  clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; /&gt;
</code></pre>
<p>修改为</p>
<pre><code>&lt;Connector port=&quot;443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;
               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot;&gt;
        &lt;SSLHostConfig&gt;
            &lt;Certificate certificateKeystoreFile=&quot;conf/www.zhehangpiaowu.cn.pfx&quot;#请替换为pfx文件。
                         certificateKeystorePassword=&quot;0sXWUh0i&quot;#请替换为密码文件pfx-password.txt中的内容。
                          certificateKeystoreType=&quot;PKCS12&quot; /&gt;
        &lt;/SSLHostConfig&gt;
    &lt;/Connector&gt;

</code></pre>
<h3 id="自动跳转至-https">自动跳转至 HTTPS</h3>
<blockquote>
<p>conf/web.xml</p>
</blockquote>
<pre><code>&lt;login-config&gt;  
    &lt;!-- Authorization setting for SSL --&gt;  
    &lt;auth-method&gt;CLIENT-CERT&lt;/auth-method&gt;  
    &lt;realm-name&gt;Client Cert Users-only Area&lt;/realm-name&gt;  
&lt;/login-config&gt;  
&lt;security-constraint&gt;  
    &lt;!-- Authorization setting for SSL --&gt;  
    &lt;web-resource-collection &gt;  
        &lt;web-resource-name &gt;SSL&lt;/web-resource-name&gt;  
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  
    &lt;/web-resource-collection&gt;  
    &lt;user-data-constraint&gt;  
        &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;  
    &lt;/user-data-constraint&gt;  
&lt;/security-constraint&gt;
</code></pre>
<h2 id="禁止ip访问">禁止IP访问</h2>
<blockquote>
<p>conf/server.xml</p>
</blockquote>
<pre><code>    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;www.baidu.com&quot;&gt; #域名地址
      &lt;Host name=&quot;www.baidu.com&quot;  appBase=&quot;webapps&quot;
            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Oracle 安装]]></title>
        <id>https://mzqk.github.io/post/oracle-an-zhuang/</id>
        <link href="https://mzqk.github.io/post/oracle-an-zhuang/">
        </link>
        <updated>2020-06-02T05:48:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="linux-安装-oracle软件">Linux 安装 Oracle软件</h1>
<h2 id="环境准备">环境准备</h2>
<h3 id="创建用户和用户组">创建用户和用户组</h3>
<pre><code class="language-bash">groupadd oinstall
groupadd dba
useradd -g oinstall -G dba oracle
passwd oracle
</code></pre>
<h3 id="安装依赖">安装依赖</h3>
<pre><code class="language-bash">yum install gcc make binutils gcc-c++ \
compat-libstdc++-33elfutils-libelf-devel \
elfutils-libelf-devel-static ksh libaio \
libaio-develnumactl-devel sysstat unixODBC \
unixODBC-devel pcre-devel –y
</code></pre>
<h3 id="内核参数调整">内核参数调整</h3>
<ol>
<li>关闭selinux</li>
</ol>
<blockquote>
<p>/etc/selinux/config</p>
</blockquote>
<pre><code class="language-bash"># 修改配置文件参数 SELINUX=disabled
setenforce 0
</code></pre>
<ol start="2">
<li>修改系统参数（可选）</li>
</ol>
<blockquote>
<p>/etc/sysctl.conf</p>
</blockquote>
<pre><code class="language-vim">fs.aio-max-nr = 1048576
fs.file-max = 6815744
#若安装数据库有ORA-27102报错，可调大kernel.shmall、kernel.shmmax值
kernel.shmall = 4294967296
#shmall 是全部允许使用的共享内存大小
kernel.shmmax = 68719476736 
#shmmax 是单个段允许使用的大小，为本机物理内存的一半，单位为byte。
kernel.shmmni = 4096
kernel.sem = 250 32000 100 128
net.ipv4.ip_local_port_range = 9000 65500
net.core.rmem_default = 262144
net.core.rmem_max = 4194304
net.core.wmem_default = 262144
net.core.wmem_max = 1048576 
</code></pre>
<pre><code class="language-bash">sysctl -p
</code></pre>
<ol start="3">
<li>修改用户限制（可选）</li>
</ol>
<blockquote>
<p>/etc/security/limits.conf</p>
</blockquote>
<pre><code class="language-bash"># 末尾添加
oracle           soft    nproc           2047
oracle           hard    nproc           16384
oracle           soft    nofile          1024
oracle           hard    nofile         65536
oracle           soft    stack           10240 
</code></pre>
<blockquote>
<p>/etc/pam.d/login</p>
</blockquote>
<pre><code class="language-bash"># 末尾添加
session required  /lib64/security/pam_limits.so
session required   pam_limits.so 
</code></pre>
<blockquote>
<p>/etc/profile</p>
</blockquote>
<pre><code class="language-bash"># 末尾添加
if [ $USER = &quot;oracle&quot; ]; then
  if [ $SHELL = &quot;/bin/ksh&quot; ]; then
      ulimit -p 16384
      ulimit -n 65536
  else
      ulimit -u 16384 -n 65536
  fi
fi 
</code></pre>
<h3 id="配置用户环境">配置用户环境</h3>
<ol>
<li>创建软件安装路径</li>
</ol>
<pre><code class="language-bash"># 目录与配置文件相关，请按需修改
mkdir -p /data/oracle/product/11.2.0
mkdir /data/oracle/oradata
mkdir /data/oracle/inventory
mkdir /data/oracle/fast_recovery_area

chown -R oracle:oinstall /data/oracle
chmod -R 775 /data/oracle
</code></pre>
<ol start="2">
<li>配置用户环境变量</li>
</ol>
<blockquote>
<p>.bash_profile</p>
</blockquote>
<pre><code class="language-vim"># 末尾添加
ORACLE_BASE=/data/oracle
ORACLE_HOME=$ORACLE_BASE/product/11.2.0
ORACLE_SID=orcl # 实例名与配置文件相关，请按需修改
PATH=$PATH:$ORACLE_HOME/bin
export ORACLE_BASE ORACLE_HOME ORACLE_SID PATH
</code></pre>
<pre><code class="language-bash">source .bash_profile
</code></pre>
<h2 id="配置信息">配置信息</h2>
<h3 id="数据库响应文件">数据库响应文件</h3>
<blockquote>
<p>db_install.rsp</p>
</blockquote>
<pre><code class="language-bash"># 静默安装，无需图形界面
oracle.install.option=INSTALL_DB_SWONLY
#主机名修改
ORACLE_HOSTNAME=centos36181
UNIX_GROUP_NAME=oinstall
INVENTORY_LOCATION=/data/oracle/inventory
SELECTED_LANGUAGES=en,zh_CN
ORACLE_HOME=/data/oracle/product/11.2.0
ORACLE_BASE=/data/oracle
oracle.install.db.InstallEdition=EE
oracle.install.db.DBA_GROUP=dba
oracle.install.db.OPER_GROUP=dba
# 客户端字符串
oracle.install.db.config.starterdb.characterSet=ZHS16GBK
DECLINE_SECURITY_UPDATES=true
</code></pre>
<h3 id="库实例响应文件">库实例响应文件</h3>
<blockquote>
<p>dbca.rsp</p>
</blockquote>
<pre><code class="language-vim"># 选择创建数据库模式
[CREATEDATABASE]

# 全局数据库的名字=SID+主机域名
GDBNAME = &quot;orcl.test&quot;
# 对应的实例名字
SID = &quot;orcl&quot;
# 建库用的模板文件
TEMPLATENAME = &quot;General_Purpose.dbc&quot;
# SYS管理员密码
SYSPASSWORD = &quot;123456&quot;
# SYSTEM管理员密码
SYSTEMPASSWORD = &quot;123456&quot;

# 数据文件存放目录
DATAFILEDESTINATION =/data/oracle/oradata
# 恢复数据存放目录
RECOVERYAREADESTINATION=/data/oracle/fast_recovery_area
# 字符集，重要!!! 建库后一般不能更改，所以建库前要确定清楚。
# (CHARACTERSET = &quot;AL32UTF8&quot; NATIONALCHARACTERSET= &quot;UTF8&quot;)
CHARACTERSET = &quot;ZHS16GBK&quot;
# oracle使用物理内存80%（可选）
TOTALMEMORY = &quot;1638&quot; 
</code></pre>
<h2 id="软件安装与卸载">软件安装与卸载</h2>
<h3 id="安装数据库">安装数据库</h3>
<pre><code class="language-bash"># 使用oracle用户
./runInstaller -silent -responseFile /database/response/db_install.rsp -ignorePrereq
</code></pre>
<p>以 root 用户的身份执行以下脚本:<br>
1. /data/oracle/inventory/orainstRoot.sh<br>
2. /data/oracle/product/11.2.0/root.sh</p>
<h3 id="配置监听">配置监听</h3>
<pre><code class="language-bash"># 使用oracle用户
netca /silent /responseFile /database/response/netca.rsp
</code></pre>
<h3 id="安装库实例">安装库实例</h3>
<pre><code class="language-bash"># 使用oracle用户
dbca -silent -responseFile /database/response/dbca.rsp
</code></pre>
<h3 id="卸载数据库">卸载数据库</h3>
<pre><code class="language-bash">dbca -silent -deleteDatabase -responseFile /database/response/dbca.rsp
</code></pre>
<h2 id="常见问题处理">常见问题处理</h2>
<ol>
<li>ORA-12514: TNS:listener does not currently know of service requested in connect<br>
修改文件/data/oracle/product/11.2.0/network/admin/listener.ora</li>
</ol>
<pre><code class="language-vim">SID_LIST_LISTENER =  
(SID_LIST =  
  (SID_DESC =  
  (GLOBAL_DBNAME = orcl)
  (SID_NAME = orcl)
  )
)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx入门]]></title>
        <id>https://mzqk.github.io/post/nginx-ji-chu-ru-men/</id>
        <link href="https://mzqk.github.io/post/nginx-ji-chu-ru-men/">
        </link>
        <updated>2019-12-25T01:35:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="nginx入门">Nginx入门</h1>
<h2 id="nginx简介">Nginx简介</h2>
<h3 id="简介">简介</h3>
<p>Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，其特点是占有内存少，并发能力强。</p>
<h3 id="特点">特点</h3>
<ol>
<li>高并发</li>
<li>内存消耗少</li>
<li>成本低廉</li>
<li>配置简单</li>
<li>内置健康检查功能</li>
<li>节省带宽</li>
<li>稳定性高</li>
<li>支持热部署</li>
</ol>
<h3 id="常见web服务器">常见WEB服务器</h3>
<ul>
<li>
<p>Apache</p>
</li>
<li>
<p>Lighttpd</p>
</li>
<li>
<p>Tomcat</p>
</li>
<li>
<p>Tengine</p>
</li>
<li>
<p>IBM WebSphere</p>
</li>
<li>
<p>IIS</p>
</li>
<li>
<p>LVS</p>
</li>
<li>
<p>HAProxy</p>
</li>
</ul>
<h2 id="nginx安装">Nginx安装</h2>
<h3 id="在线安装">在线安装</h3>
<h4 id="linux">Linux</h4>
<p>apt install nginx</p>
<p>yum install nginx</p>
<p>查询默认配置文件<br>
nginx -t</p>
<h4 id="windows">Windows</h4>
<p>官网下载ngixn文件解压至制定目录</p>
<h3 id="源码安装">源码安装</h3>
<ol>
<li>下载源码包（包含基础依赖包，如prce库）</li>
<li>./configure 根据需求进行配置</li>
<li>make install 指定目录安装</li>
</ol>
<pre><code class="language-shell">wget http://nginx.org/download/nginx-1.16.1.tar.gz
tar -zxvf nginx-1.16.1.tar.gz
./configure
    --sbin-path=/usr/local/nginx/nginx
    --conf-path=/usr/local/nginx/nginx.conf
    --pid-path=/usr/local/nginx/nginx.pid
    --with-http_ssl_module
make &amp;&amp; make install
</code></pre>
<p><a href="http://nginx.org/en/docs/configure.html">官方编译参数</a></p>
<h2 id="nginx基础">Nginx基础</h2>
<h3 id="基础使用">基础使用</h3>
<h4 id="启动">启动</h4>
<pre><code class="language-shell">nginx #正常启动应用
nginx -c /etc/nginx/conf/nginx.conf #指定配置文件启动 
</code></pre>
<h4 id="停止">停止</h4>
<pre><code class="language-shell">nginx -s stop #停止nginx应用
pkill -9 nginx #停止nginx所有进程
kill -INT `cat /run/nginx.pid` #指定pid发起停止信号
</code></pre>
<h4 id="平滑重启">平滑重启</h4>
<pre><code class="language-shell">nginx -s reload #重启应用
kill -HUP `cat /run/nginx.pid` #指定pid发起重启信号
</code></pre>
<h3 id="基础配置">基础配置</h3>
<h4 id="目录结构">目录结构</h4>
<pre><code>/etc/nginx/
├── conf.d
├── default.d
├── fastcgi.conf
├── fastcgi.conf.default
├── fastcgi_params
├── fastcgi_params.default
├── koi-utf
├── koi-win
├── mime.types
├── mime.types.default
├── nginx.conf
├── nginx.conf.default
├── nginx.conf.rpmnew
├── scgi_params
├── scgi_params.default
├── uwsgi_params
├── uwsgi_params.default
└── win-utf
</code></pre>
<pre><code>/usr/share/nginx/
├── html
│   ├── 404.html
│   ├── 50x.html
│   ├── 50x.html_bak
│   ├── en-US -&gt; ../../doc/HTML/en-US
│   ├── icons
│   │   └── poweredby.png -&gt; ../../../pixmaps/poweredby.png
│   ├── img -&gt; ../../doc/HTML/img
│   ├── index.html -&gt; ../../doc/HTML/index.html
│   ├── index.html_bak
│   ├── nginx-logo.png
│   └── poweredby.png -&gt; nginx-logo.png
└── modules
    ├── mod-http-image-filter.conf
    ├── mod-http-perl.conf
    ├── mod-http-xslt-filter.conf
    ├── mod-mail.conf
    └── mod-stream.conf
</code></pre>
<pre><code>/var/log/nginx/
├── access.log
└── error.log

/run/nginx.pid 
</code></pre>
<h4 id="配置文件">配置文件</h4>
<pre><code class="language-shell">#主配置
user www www; #使用用户和组
worker_processes auto; #工作进程数
error_log /var/log/nginx/error.log; #错误日志保存位置
pid /run/nginx.pid; #进程pid存放位置

include /usr/share/nginx/modules/*.conf;  #模块加载目录
#事件模型
events {
    worker_connections 1024; #最大连接数
}
#http服务器
http {
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; #日志输出格式

    access_log  /var/log/nginx/access.log  main; #标准日志保存位置

    sendfile            on; #开启高效文件传输模式，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。
    tcp_nopush          on;	#此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用
    tcp_nodelay         on; #将连接转变为长连接
    keepalive_timeout   65; #长连接超时时间，单位是秒
    types_hash_max_size 2048; 

    include             /etc/nginx/mime.types; #设定mime类型,类型由mime.type文件定义
    default_type        application/octet-stream; 

    include /etc/nginx/conf.d/*.conf; #加载其他配置文件
    # 虚拟主机
    server {
        listen       80 default_server;
        listen       [::]:80 default_server; #监听端口
        server_name  _;  #域名，可以有多个
        root         /usr/share/nginx/html; #web服务器根目录

        include /etc/nginx/default.d/*.conf; #加载其他配置文件

        location / {
            proxy_pass        http://127.0.0.1/;
            proxy_set_header   Host             $host;
            proxy_set_header   X-Real-IP        $remote_addr;
            proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for; #获取用户真实IP
        }

        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }
}
</code></pre>
<h3 id="基础优化">基础优化</h3>
<h4 id="日志文件配置">日志文件配置</h4>
<pre><code class="language-shell">#!/bin/bash
#脚本用于切割nginx日志文件
#请配置脚本为每天00:00启动
#crontab -e 00 00 * * * /bin/bash /root/spilt_nginx_log.sh

#设置nginx日志文件目录
log_path=&quot;/var/log/nginx/&quot;

#根据时间切割日志文件
mkdir -p ${log_path}${date -d &quot;yesterday&quot; +&quot;%Y%m&quot;}
mv ${log_path}access.log ${log_path}${date -d &quot;yesterday&quot; +&quot;%Y%m&quot;}/access_${date -d &quot;yesterday&quot; +&quot;%Y%m%d&quot;}.log

#重启nginx
kill -HUP `cat /run/nginx.pid`
</code></pre>
<h4 id="压缩输出配置">压缩输出配置</h4>
<pre><code>gzip on;
gzip_mini_length 1k;
gzip_buffer 4 16k;
gzip_http_version 1.1;
gzip_comp_level 2;
gzip_tesxt_plain application/x-javascript text/css application/xml;
gzip_vary on;
</code></pre>
<h4 id="缓存配置">缓存配置</h4>
<pre><code>location ~ .*\.{git|jpg|jpeg|png|bmp|swf}$
{
    expires 30d;
}
location ~ .*\.{js|css}?$
{
    expires 1h;
}
</code></pre>
<h4 id="url重写">URL重写</h4>
<pre><code>#根据浏览器标识，访问资源重定向到指定文件目录（以下为IE)
if ($http_user_agent ~ MSIE ) {
   rewrite ^(.*)$ /msie/$1 break;
}

#将移动客户端的请求重定向到其他服务器
if    ($http_user_agent ~* '(iphone|ipod)' )  { 
　　　　rewrite ^.+    http://mobile.site.com$uri;
}

#.用户使用POST方式请求数据时候，返回405：
if ($request_method = POST ) {
   return 405;
}

#访问xxxx时重定向到xxxx目录
location /xxxx {
     rewrite ^/xxxx/.*$ /xxxx permanent;
}
</code></pre>
<h2 id="nginx常用功能">Nginx常用功能</h2>
<h3 id="反向代理">反向代理</h3>
<pre><code class="language-shell"> http{
 	server{
        listen       80;
        server_name  localhost;
        location / { 
        proxy_pass http://localhost:8080;     
 	}
 }
</code></pre>
<h3 id="负载均衡">负载均衡</h3>
<p><a href="http://nginx.org/en/docs/http/load_balancing.html">官方说明</a></p>
<pre><code class="language-shell">http {
 upstream myproject {
 server 127.0.0.1:8000 weight=3;
 server 127.0.0.1:8001;
 server 127.0.0.1:8002;
 server 127.0.0.1:8003;
 }
 	server {
 	listen 80;
	 server_name www.domain.com;
 	location / {
 		proxy_pass http://myproject;
 		}
 	}
}
</code></pre>
<h3 id="正向代理">正向代理</h3>
<pre><code class="language-shell">http{
    server{
        listen 8888;
        location / {
            resolver 8.8.8.8;
            proxy_pass	http://$http_host$request_uri;
        }
    }
}
</code></pre>
<h3 id="http服务器ssl">HTTP服务器（SSL）</h3>
<p><a href="http://nginx.org/en/docs/http/configuring_https_servers.html">官方说明</a></p>
<pre><code class="language-shell">http {
  server {
    listen	443;
    server_name	localhost;
    ssl	on;
    ssl_certificate      /usr/local/nginx/conf/cert.pem;
    ssl_certificate_key  /usr/local/nginx/conf/cert.key;
  }
}
</code></pre>
<h3 id="文件服务器">文件服务器</h3>
<pre><code class="language-shell">http{
    server{
        listen 80;
        server_name localhost;
        root /usr/share/nginx/html/;
    }
}
</code></pre>
<h3 id="负载均衡-2">负载均衡</h3>
<pre><code>http{
	upstream myproject {
        server 192.168.1.112:8001;
        server 192.168.1.112:8002;
        server 192.168.1.112:8003;
    	}

	proxy_buffering on;
	proxy_cache_valid any 10m;
	proxy_cache_path /data/cache levels=1:2 keys_zone=my_cache:10m max_size=1000m inactive=600m;
	proxy_temp_path /data/temp;
	proxy_buffer_size 4k;
	proxy_buffers 100 8k;

	server {
    	listen       80;
    	server_name  localhost jeson.t.imooc.io; 
    	location / {
        	proxy_cache my_cache;  #开启缓存
       		proxy_pass http://myproject;
            proxy_cache_key $host$uri$is_args$args; #定义缓存的key
    }
}
</code></pre>
<h2 id="nginx模块">Nginx模块</h2>
<h3 id="http模块">HTTP模块</h3>
<ul>
<li><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html">ngx_http_core_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_access_module.html">ngx_http_access_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_addition_module.html">ngx_http_addition_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_api_module.html">ngx_http_api_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_auth_jwt_module.html">ngx_http_auth_jwt_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_auth_request_module.html">ngx_http_auth_request_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_autoindex_module.html">ngx_http_autoindex_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_browser_module.html">ngx_http_browser_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_charset_module.html">ngx_http_charset_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_dav_module.html">ngx_http_dav_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_empty_gif_module.html">ngx_http_empty_gif_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_f4f_module.html">ngx_http_f4f_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html">ngx_http_fastcgi_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_flv_module.html">ngx_http_flv_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_geo_module.html">ngx_http_geo_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_geoip_module.html">ngx_http_geoip_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_grpc_module.html">ngx_http_grpc_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_gunzip_module.html">ngx_http_gunzip_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html">ngx_http_gzip_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_gzip_static_module.html">ngx_http_gzip_static_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_headers_module.html">ngx_http_headers_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_hls_module.html">ngx_http_hls_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_image_filter_module.html">ngx_http_image_filter_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_index_module.html">ngx_http_index_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_js_module.html">ngx_http_js_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_keyval_module.html">ngx_http_keyval_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html">ngx_http_limit_conn_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html">ngx_http_limit_req_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_log_module.html">ngx_http_log_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_map_module.html">ngx_http_map_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_memcached_module.html">ngx_http_memcached_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_mirror_module.html">ngx_http_mirror_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_mp4_module.html">ngx_http_mp4_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_perl_module.html">ngx_http_perl_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">ngx_http_proxy_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_random_index_module.html">ngx_http_random_index_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_realip_module.html">ngx_http_realip_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_referer_module.html">ngx_http_referer_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html">ngx_http_rewrite_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_scgi_module.html">ngx_http_scgi_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_secure_link_module.html">ngx_http_secure_link_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_session_log_module.html">ngx_http_session_log_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_slice_module.html">ngx_http_slice_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_spdy_module.html">ngx_http_spdy_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_split_clients_module.html">ngx_http_split_clients_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_ssi_module.html">ngx_http_ssi_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html">ngx_http_ssl_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_status_module.html">ngx_http_status_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_stub_status_module.html">ngx_http_stub_status_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_sub_module.html">ngx_http_sub_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html">ngx_http_upstream_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_upstream_conf_module.html">ngx_http_upstream_conf_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_upstream_hc_module.html">ngx_http_upstream_hc_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_userid_module.html">ngx_http_userid_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_uwsgi_module.html">ngx_http_uwsgi_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_v2_module.html">ngx_http_v2_module</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_xslt_module.html">ngx_http_xslt_module</a></li>
</ul>
<h3 id="邮箱模块">邮箱模块</h3>
<ul>
<li><a href="http://nginx.org/en/docs/mail/ngx_mail_core_module.html">ngx_mail_core_module</a></li>
<li><a href="http://nginx.org/en/docs/mail/ngx_mail_auth_http_module.html">ngx_mail_auth_http_module</a></li>
<li><a href="http://nginx.org/en/docs/mail/ngx_mail_proxy_module.html">ngx_mail_proxy_module</a></li>
<li><a href="http://nginx.org/en/docs/mail/ngx_mail_ssl_module.html">ngx_mail_ssl_module</a></li>
<li><a href="http://nginx.org/en/docs/mail/ngx_mail_imap_module.html">ngx_mail_imap_module</a></li>
<li><a href="http://nginx.org/en/docs/mail/ngx_mail_pop3_module.html">ngx_mail_pop3_module</a></li>
<li><a href="http://nginx.org/en/docs/mail/ngx_mail_smtp_module.html">ngx_mail_smtp_module</a></li>
</ul>
<h3 id="strean模块">Strean模块</h3>
<ul>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html">ngx_stream_core_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_access_module.html">ngx_stream_access_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_geo_module.html">ngx_stream_geo_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_geoip_module.html">ngx_stream_geoip_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_js_module.html">ngx_stream_js_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_keyval_module.html">ngx_stream_keyval_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_limit_conn_module.html">ngx_stream_limit_conn_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_log_module.html">ngx_stream_log_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_map_module.html">ngx_stream_map_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_proxy_module.html">ngx_stream_proxy_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_realip_module.html">ngx_stream_realip_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_return_module.html">ngx_stream_return_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_split_clients_module.html">ngx_stream_split_clients_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_ssl_module.html">ngx_stream_ssl_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_ssl_preread_module.html">ngx_stream_ssl_preread_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_upstream_module.html">ngx_stream_upstream_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_upstream_hc_module.html">ngx_stream_upstream_hc_module</a></li>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_zone_sync_module.html">ngx_stream_zone_sync_module</a></li>
</ul>
<h2 id="slb实例">SLB实例</h2>
<h3 id="产品架构">产品架构</h3>
<h4 id="基础架构说明">基础架构说明</h4>
<p>阿里云当前提供四层和七层的负载均衡服务。</p>
<ul>
<li>四层采用开源软件LVS（Linux Virtual Server）+ keepalived的方式实现负载均衡，并根据云计算需求对其进行了个性化定制。</li>
<li>七层采用Tengine实现负载均衡。Tengine是由淘宝网发起的Web服务器项目，它在Nginx的基础上，针对有大访问量的网站需求，添加了很多高级功能和特性。<br>
<a href="http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/4092/1566871290938_zh-CN.png"><img src="http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/4092/1566871290938_zh-CN.png" alt="Tengine" loading="lazy"></a></li>
</ul>
<p>如下图所示，各个地域的四层负载均衡实际上是由多台LVS机器部署成一个LVS集群来运行的。采用集群部署模式极大地保证了异常情况下负载均衡服务的可用性、稳定性与可扩展性。</p>
<figure data-type="image" tabindex="1"><img src="http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/4092/1566871290939_zh-CN.png" alt="LVS" loading="lazy"></figure>
<p>LVS集群内的每台LVS都会进行会话，通过组播报文同步到该集群内的其它LVS机器上，从而实现LVS集群内各台机器间的会话同步。如下图所示，当客户端向服务端传输三个数据包后，在LVS1上建立的会话A开始同步到其它LVS机器上。图中实线表示现有的连接，图中虚线表示当LVS1出现故障或进行维护时，这部分流量会走到一台可以正常运行的机器LVS2上。因而负载均衡集群支持热升级，并且在机器故障和集群维护时最大程度对用户透明，不影响用户业务。</p>
<p><strong>说明</strong> 对于连接未建立（三次握手未完成），或者已建立连接但未触发会话同步机制，热升级不保证连接不中断，需要依靠客户端重新发起连接。</p>
<figure data-type="image" tabindex="2"><img src="http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/4092/1566871290941_zh-CN.png" alt="LVS" loading="lazy"></figure>
<h4 id="入网流量路径">入网流量路径</h4>
<p>对于入网流量，负载均衡会根据用户在控制台或API上配置的转发策略，对来自前端的访问请求进行转发和处理，数据流转如<a href="https://help.aliyun.com/document_detail/27544.html?spm=a2c4g.11186623.6.546.3bdf54931Vjryc#d7e30">图 1</a>所示。</p>
<p>图 1. 入网流量路径<br>
<a href="http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/4114/15668712912333_zh-CN.png"><img src="http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/4114/15668712912333_zh-CN.png" alt="img" loading="lazy"></a></p>
<ol>
<li>TCP/UDP协议和HTTP/HTTPS协议的流量都需要经过LVS集群进行转发。</li>
<li>LVS集群内的每一台节点服务器均匀地分配海量访问请求，并且每一台节点服务器之间都有会话同步策略，以保证高可用。
<ul>
<li>如果相应的负载均衡实例服务端口使用的是四层协议（TCP或UDP），那么LVS集群内每个节点都会根据负载均衡实例负载均衡策略，将其承载的服务请求按策略直接分发到后端ECS服务器。</li>
<li>如果相应的负载均衡实例服务端口使用的是七层HTTP协议，那么LVS集群内每个节点会先将其承载的服务请求均分到Tengine集群，Tengine集群内的每个节点再根据负载均衡策略，将服务请求按策略最终分发到后端ECS服务器。</li>
<li>如果相应的负载均衡实例服务端口使用的是七层HTTPS协议，与上述HTTP处理过程类似，差别是在按策略将服务请求最终分发到后端ECS服务器前，先调用Key Server进行证书验证及数据包加解密等前置操作。</li>
</ul>
</li>
</ol>
<h4 id="出网流量路径">出网流量路径</h4>
<p>负载均衡SLB和后端ECS之间是通过内网进行通信的。</p>
<ul>
<li>
<p>如果ECS仅仅处理来自负载均衡的请求，可以不购买公网带宽（ECS公网IP/弹性公网IP/NAT网关等）。</p>
<p><strong>说明</strong> 早期创建的一些ECS上直接分配了公网IP（ifconfig中可见接口上分配的公网ip地址），此类ECS如果仅通过SLB对外提供服务，即便在公网接口（网卡）上看到有流量统计，也不会产生ECS的公网费用。</p>
</li>
<li>
<p>如果需要直接通过后端ECS对外提供服务，或后端ECS有访问外网的需求， 那么需要相应的配置或购买ECS公网IP/弹性公网IP/NAT网关等服务。</p>
</li>
</ul>
<p>ECS的公网流量访问路径如<a href="https://help.aliyun.com/document_detail/27544.html?spm=a2c4g.11186623.6.546.3bdf54931Vjryc#d7e90">图 2</a>所示。</p>
<p>图 2. 出网流量路径<br>
<a href="http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/4114/15668712912335_zh-CN.png"><img src="http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/4114/15668712912335_zh-CN.png" alt="img" loading="lazy"></a></p>
<p>总体原则：流量从哪里进来，就从哪里出去。</p>
<ol>
<li>通过负载均衡进入的流量在负载均衡SLB上限速/计费，仅收取出方向流量费用，入方向流量不收取（在未来可能会改变），SLB到ECS之间是阿里云内网通信，不收取流量费用。</li>
<li>来自弹性公网IP/NAT网关的流量，分别在弹性公网IP/NAT网关上进行限速/计费，如果在购买ECS时选择了公网带宽，限速/计费点在ECS上。</li>
<li>负载均衡SLB仅提供被动访问公网的能力，即后端ECS只能在收到通过负载均衡SLB转发来的公网的请求时，才能访问公网回应该请求，如后端ECS希望主动发起公网访问，则需要配置/购买ECS公网带宽、弹性公网IP或NAT网关来实现。</li>
<li>ECS公网带宽（购买ECS时配置）、弹性公网IP、NAT网关均可以实现ECS的双向公网访问（访问或被访问），但没有流量分发和负载均衡的能力。</li>
</ol>
<h3 id="快速入门">快速入门</h3>
<video id="video" controls="" preload="none" poster="">
 <source id="mp4" src="https://cloud.video.taobao.com/play/u/3171458687/p/1/e/6/t/1/50265550292.mp4" type="video/mp4">
</video>
<p>​</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用 Docker 部署 Seafile 服务]]></title>
        <id>https://mzqk.github.io/post/yong-docker-bu-shu-seafile-fu-wu/</id>
        <link href="https://mzqk.github.io/post/yong-docker-bu-shu-seafile-fu-wu/">
        </link>
        <updated>2019-06-17T01:44:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="用-docker-部署-seafile-服务">用 Docker 部署 Seafile 服务</h1>
<h2 id="快速开始">快速开始</h2>
<h3 id="安装-docker-compose">安装 docker-compose</h3>
<p>因为 Seafile v7.x.x 容器是通过 docker-compose 命令运行的，所以您应该先在服务器上安装该命令。</p>
<pre><code class="language-bash"># for CentOS
yum install docker-compose -y

# for Ubuntu
apt-get install docker-compose -y

</code></pre>
<h3 id="下载并修改-docker-composeyml">下载并修改 docker-compose.yml</h3>
<p>下载 <a href="https://docs.seafile.com/d/cb1d3f97106847abbf31/files/?p=/docker/pro-edition/docker-compose.yml">docker-compose.yml</a> 示例文件到您的服务器上，然后根据您的实际环境修改该文件。尤其是以下几项配置：</p>
<ul>
<li>MySQL root 用户的密码 (MYSQL_ROOT_PASSWORD and DB_ROOT_PASSWD)</li>
<li>持久化存储 MySQL 数据的 volumes 目录 (volumes)</li>
<li>持久化存储 Seafile 数据的 volumes 目录 (volumes)</li>
<li>持久化存储 Elasticsearch 索引数据的 volumes 目录 (volumes)</li>
</ul>
<h3 id="启动-seafile-服务">启动 Seafile 服务</h3>
<p>执行以下命令启动 Seafile 服务</p>
<pre><code class="language-bash">docker-compose up -d

</code></pre>
<p>需要等待几分钟，等容器首次启动时的初始化操作完成后，您就可以在浏览器上访问<code>http://seafile.example.com</code> 来打开 Seafile 主页。</p>
<p>**注意：您应该在 **<code>docker-compose.yml</code><strong>文件所在的目下执行以上命令。</strong></p>
<h3 id="安装授权文件seafile-licensetxt">安装授权文件(seafile-license.txt)</h3>
<p>如果您已经向 Seafile 软件商购买了专业版的授权文件<code>seafile-license.txt</code>，您只需要将该授权文件拷贝至 Seafile 数据持久化目录中的<code>seafile/</code>目录下，然后重启docker容器，即可完成授权文件的安装。 假如，Seafile 数据持久化目录为<code>/opt/seafile-data</code>，那么，在您的宿主机上执行以下操作：</p>
<pre><code>cp /path/to/seafile-license.txt /opt/seafile-data/seafile/

</code></pre>
<p>然后重启这个容器：</p>
<pre><code>docker-compose restart

</code></pre>
<h2 id="更多配置项">更多配置项</h2>
<h3 id="自定义管理员用户名和密码">自定义管理员用户名和密码</h3>
<p>默认的管理员账号是 <code>me@example.com</code> 并且该账号的密码是 <code>asecret</code>，您可以在 <code>docker-compose.yml</code> 中配置不同的用户名和密码，为此您需要做如下配置：</p>
<pre><code>seafile:
    ...

    environment:
        ...
        - SEAFILE_ADMIN_EMAIL=me@example.com
        - SEAFILE_ADMIN_PASSWORD=a_very_secret_password
        ...

</code></pre>
<h3 id="使用-lets-encrypt-ssl-证书">使用 Let's encrypt SSL 证书</h3>
<p>如果您把 <code>SEAFILE_SERVER_LETSENCRYPT</code> 设置为 <code>true</code>，该容器将会自动为您申请一个 letsencrypt 机构颁发的 SSL 证书，并开启 https 访问，为此您需要做如下配置：</p>
<pre><code>seafile:
    ...
    ports:
        - &quot;80:80&quot;
        - &quot;443:443&quot;
    ...
    environment:
        ...
        - SEAFILE_SERVER_LETSENCRYPT=true
        - SEAFILE_SERVER_HOSTNAME=seafile.example.com
        ...

</code></pre>
<p>如果您想要使用自己的 SSL 证书，而且如果用来持久化存储 Seafile 数据的目录为 <code>/opt/seafile-data</code>，您可以做如下处理：</p>
<ul>
<li>创建 <code>/opt/seafile-data/ssl</code> 目录，然后拷贝您的证书文件和密钥文件到ssl目录下。</li>
<li>假设您的站点名称是 <code>seafile.example.com</code>，那么您的证书名称必须就是 <code>seafile.example.com.crt</code>，密钥文件名称就必须是 <code>seafile.example.com.key</code>。</li>
</ul>
<h3 id="修改-seafile-服务的配置">修改 Seafile 服务的配置</h3>
<p>Seafile 的配置文件存放在 <code>shared/seafile/conf</code> 目录下，您可以根据<a href="https://manual-cn.seafile.com/">Seafile 手册</a>的指导来修改这些配置项。</p>
<p>一旦修改了配置文件，您需要重启服务以使其生效：</p>
<pre><code class="language-bash">docker-compose restart

</code></pre>
<h3 id="查找日志">查找日志</h3>
<p>Seafile 容器中 Seafile 服务本身的日志文件存放在 <code>/shared/logs/seafile</code> 目录下，或者您可以在宿主机上 Seafile 容器的卷目录中找到这些日志，例如：<code>/opt/seafile-data/logs/seafile</code></p>
<p>同样 Seafile 容器的系统日志存放在 <code>/shared/logs/var-log</code> 目录下，或者宿主机目录 <code>/opt/seafile-data/logs/var-log</code>。</p>
<h3 id="增加一个新的管理员">增加一个新的管理员</h3>
<p>确保各容器正常运行，然后执行以下命令：</p>
<pre><code class="language-bash">docker exec -it seafile /opt/seafile/seafile-server-latest/reset-admin.sh

</code></pre>
<p>根据提示输入用户名和密码，您现在有了一个新的管理帐户。</p>
<h2 id="seafile-目录结构">Seafile 目录结构</h2>
<h3 id="shared"><code>/shared</code></h3>
<p>共享卷的挂载点,您可以选择在容器外部存储某些持久性信息.在这个项目中，我们会在外部保存各种日志文件和上传数据。 这使您可以轻松重建容器而不会丢失重要信息。</p>
<ul>
<li>/shared/seafile: Seafile 服务的配置文件以及数据文件</li>
<li>/shared/logs: 日志目录
<ul>
<li>/shared/logs/var-log: 我们将容器内的<code>/var/log</code>链接到本目录。您可以在<code>/shared/logs/var-log/nginx/</code>中找到 nginx 的日志文件</li>
<li>/shared/logs/seafile: Seafile 服务运行产生的日志文件目录。比如您可以在 <code>/shared/logs/seafile/seafile.log</code> 文件中看到 seaf-server 的日志</li>
</ul>
</li>
<li>/shared/ssl: 存放证书的目录，默认不存在</li>
</ul>
<h3 id="升级-seafile-服务">升级 Seafile 服务</h3>
<p>如果要升级 Seafile 服务到最新版本：</p>
<pre><code class="language-sh">docker pull docker.seafile.top/seafileltd/seafile-pro-mc:latest
docker-compose down
docker-compose up -d

</code></pre>
<h2 id="备份和恢复">备份和恢复</h2>
<h3 id="目录结构">目录结构</h3>
<p>我们假设您的 seafile 数据卷路径是 <code>/opt/seafile-data</code>，并且您想将备份数据存放到 <code>/opt/seafile-backup</code> 目录下。</p>
<p>您可以创建一个类似以下 <code>/opt/seafile-backup</code> 的目录结构：</p>
<pre><code class="language-struct">/opt/seafile-backup
---- databases/  用来存放 MySQL 容器的备份数据
---- data/  用来存放 Seafile 容器的备份数据

</code></pre>
<p>要备份的数据文件：</p>
<pre><code class="language-struct">/opt/seafile-data/seafile/conf  # configuration files
/opt/seafile-data/seafile/seafile-data # data of seafile
/opt/seafile-data/seafile/seahub-data # data of seahub

</code></pre>
<h3 id="备份数据">备份数据</h3>
<p>步骤：</p>
<ol>
<li>备份 MySQL 数据库数据；</li>
<li>备份 Seafile 数据目录；</li>
</ol>
<ul>
<li>
<p>备份数据库：</p>
<pre><code class="language-bash"># 建议每次将数据库备份到一个单独的文件中。至少在一周内不要覆盖旧的数据库备份。
cd /opt/seafile-backup/databases
docker exec -it seafile-mysql mysqldump  -uroot --opt ccnet_db &gt; ccnet_db.sql
docker exec -it seafile-mysql mysqldump  -uroot --opt seafile_db &gt; seafile_db.sql
docker exec -it seafile-mysql mysqldump  -uroot --opt seahub_db &gt; seahub_db.sql

</code></pre>
</li>
<li>
<p>备份 Seafile 资料库数据：</p>
<ul>
<li>
<p>直接复制整个数据目录</p>
<pre><code class="language-bash">cp -R /opt/seafile-data/seafile /opt/seafile-backup/data/
cd /opt/seafile-backup/data &amp;&amp; rm -rf ccnet

</code></pre>
</li>
<li>
<p>使用 rsync 执行增量备份</p>
<pre><code class="language-bash">rsync -az /opt/seafile-data/seafile /opt/seafile-backup/data/
cd /opt/seafile-backup/data &amp;&amp; rm -rf ccnet

</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="恢复数据">恢复数据</h3>
<ul>
<li>
<p>恢复数据库：</p>
<pre><code class="language-bash">docker cp /opt/seafile-backup/databases/ccnet_db.sql seafile-mysql:/tmp/ccnet_db.sql
docker cp /opt/seafile-backup/databases/seafile_db.sql seafile-mysql:/tmp/seafile_db.sql
docker cp /opt/seafile-backup/databases/seahub_db.sql seafile-mysql:/tmp/seahub_db.sql

docker exec -it seafile-mysql /bin/sh -c &quot;mysql -uroot ccnet_db &lt; /tmp/ccnet_db.sql&quot;
docker exec -it seafile-mysql /bin/sh -c &quot;mysql -uroot seafile_db &lt; /tmp/seafile_db.sql&quot;
docker exec -it seafile-mysql /bin/sh -c &quot;mysql -uroot seahub_db &lt; /tmp/seahub_db.sql&quot;

</code></pre>
</li>
<li>
<p>恢复 seafile 数据：</p>
<pre><code class="language-bash">cp -R /opt/seafile-backup/data/* /opt/seafile-data/seafile/

</code></pre>
</li>
</ul>
<h2 id="垃圾回收">垃圾回收</h2>
<p>在 seafile 中，当文件被删除时，组成这些文件的块数据不会立即删除，因为可能有其他文件也会引用这些块数据(用于去重功能的实现)。为了真正删除无用的块数据，还需要额外运行&quot;<a href="https://manual-cn.seafile.com/maintain/seafile_gc.html">GC</a>&quot;程序。GC 会自动检测到哪些数据块不再被任何文件所引用，并清除它们。</p>
<p>GC 脚本被放在docker容器的 <code>/scripts</code> 目录下。执行 GC 的方法很简单：<code>docker exec seafile /scripts/gc.sh</code>。对于社区版来说，该程序会暂停 Seafile 服务，但这是一个相对较快的程序，一旦程序运行完成，Seafile 服务也会自动重新启动。而专业版提供了在线运行 GC 的功能，不会暂停 Seafile 服务。</p>
<h2 id="问题排查">问题排查</h2>
<p>您可以运行 <code>docker exec</code> 之类的docker命令来查找错误。</p>
<pre><code class="language-sh">docker exec -it seafile /bin/bash

</code></pre>
]]></content>
    </entry>
</feed>